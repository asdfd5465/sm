package bankwiser.bankpromotion.material.crypto

import android.util.Log
import java.io.InputStream
import java.io.OutputStream
// import java.security.SecureRandom // No longer needed for IV generation here
import javax.crypto.Cipher
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec

private const val TAG = "FileEncryptionHelper"
private const val BUFFER_SIZE = 8192 // 8KB buffer

class FileEncryptionHelper(private val keyStoreHelper: KeyStoreHelper) {

    // Cipher for encryption - IV will be generated by the provider
    private fun getEncryptionCipher(): Pair<Cipher, ByteArray?> {
        val secretKey: SecretKey = keyStoreHelper.getOrCreateAESKey()
        val cipher = Cipher.getInstance(EncryptionConstants.AES_TRANSFORMATION)
        // For keys from AndroidKeyStore with GCM, IV is generated by the Cipher provider
        // So, do not pass GCMParameterSpec during ENCRYPT_MODE init
        cipher.init(Cipher.ENCRYPT_MODE, secretKey)
        val iv = cipher.iv // Get the IV generated by the provider
        return Pair(cipher, iv)
    }

    // Cipher for decryption - IV must be provided
    private fun getDecryptionCipher(iv: ByteArray): Cipher {
        val secretKey: SecretKey = keyStoreHelper.getOrCreateAESKey()
        val cipher = Cipher.getInstance(EncryptionConstants.AES_TRANSFORMATION)
        val gcmParamSpec = GCMParameterSpec(EncryptionConstants.GCM_TAG_LENGTH_BITS, iv)
        cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmParamSpec)
        return cipher
    }

    fun encrypt(inputStream: InputStream, outputStream: OutputStream): Boolean {
        var success = false
        try {
            val (cipher, iv) = getEncryptionCipher()

            if (iv == null || iv.size != EncryptionConstants.GCM_IV_LENGTH_BYTES) {
                Log.e(TAG, "Encryption failed: Invalid IV generated by Keystore provider.")
                return false
            }
            outputStream.write(iv) // Prepend the system-generated IV to the encrypted data
            Log.d(TAG, "Encryption: IV written, length: ${iv.size}")

            val buffer = ByteArray(BUFFER_SIZE)
            var bytesRead: Int

            while (inputStream.read(buffer).also { bytesRead = it } != -1) {
                val encryptedBytes = cipher.update(buffer, 0, bytesRead)
                if (encryptedBytes != null) {
                    outputStream.write(encryptedBytes)
                }
            }
            val finalEncryptedBytes = cipher.doFinal()
            if (finalEncryptedBytes != null) {
                outputStream.write(finalEncryptedBytes)
            }
            success = true
            Log.i(TAG, "Encryption successful.")
        } catch (e: Exception) {
            Log.e(TAG, "Encryption failed", e)
            success = false
        } finally {
            try { inputStream.close() } catch (e: Exception) { Log.e(TAG, "Error closing input stream", e) }
            try { outputStream.close() } catch (e: Exception) { Log.e(TAG, "Error closing output stream", e)}
        }
        return success
    }

    fun decrypt(inputStream: InputStream, outputStream: OutputStream): Boolean {
        var success = false
        try {
            val iv = ByteArray(EncryptionConstants.GCM_IV_LENGTH_BYTES)
            val ivReadCount = inputStream.read(iv)
            if (ivReadCount != EncryptionConstants.GCM_IV_LENGTH_BYTES) {
                Log.e(TAG, "Decryption failed: Could not read full IV from stream. Read $ivReadCount bytes.")
                return false
            }
            Log.d(TAG, "Decryption: IV read, length: ${iv.size}")

            val cipher = getDecryptionCipher(iv)
            val buffer = ByteArray(BUFFER_SIZE)
            var bytesRead: Int

            while (inputStream.read(buffer).also { bytesRead = it } != -1) {
                val decryptedBytes = cipher.update(buffer, 0, bytesRead)
                if (decryptedBytes != null) {
                    outputStream.write(decryptedBytes)
                }
            }
            val finalDecryptedBytes = cipher.doFinal() // This will throw AEADBadTagException if auth tag mismatch
            if (finalDecryptedBytes != null) {
                outputStream.write(finalDecryptedBytes)
            }
            success = true
            Log.i(TAG, "Decryption successful.")
        } catch (e: Exception) { // javax.crypto.AEADBadTagException is a common one here for bad key/data
            Log.e(TAG, "Decryption failed", e)
            success = false
        } finally {
            try { inputStream.close() } catch (e: Exception) { Log.e(TAG, "Error closing input stream", e) }
            try { outputStream.close() } catch (e: Exception) { Log.e(TAG, "Error closing output stream", e) }
        }
        return success
    }
}
